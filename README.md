Сравнение создания массивов (списков) и организации стеков в Java, Python и C++ (Клементьев Ярослав, УИБО-10-24)
Программы для создания массивов/списков в Python, Java и C++

 # Python
    #Создание списка(массива)
    num = [1, 2, 3, 4, 5]

    # Добавление элементов
    num.append(6)

    # Удаление элементов
    num.pop()

    # Создание стека с помошью deque
    from collections import deque
    stack_deque = deque()
    stack_deque.append('a')  # Добавление элемента в стек (push)
    stack_deque.append('b')  
    stack_deque.append('c')  
    popped = stack_deque.pop()  # Удаление и получение верхнего элемента (pop)
    
Динамический размер.

Может содержать элементы разных типов.

Встроенные методы для работы (append, pop, remove и т.д.).

Индексация с нуля, поддержка отрицательных индексов.Python: collections.deque

В Python дек реализован в модуле collections как класс deque. Это высокооптимизированная реализация на основе двусвязного списка блоков (block-based linked list), которая обеспечивает примерно одинаково быстрые операции с обоих концов.

Особенности:

· Автоматическое управление памятью.
· Потокобезопасность для операций с разными концами.
· Поддерживает максимальную длину (при переполнении элементы с противоположного конца вытесняются).
· Эффективные операции добавления/удаления: O(1).
· Операции доступа к элементу по индексу (посередине) — O(n).

# Java
    import java.util.ArrayList;
    import java.util.List;
    import java.util.Stack;

    public class Main {
        public static void main(String[] args) {
        
            // Создание ArrayList (динамического массива)
            List<Integer> myList = new ArrayList<>();
            myList.add(1);  // Добавление элемента
            myList.add(2);  // 
            myList.add(3);  // 
            myList.add(4);  // 
            myList.add(5);  // 
        
            // Добавление элемента в конец списка
            myList.add(6);
        
            // Удаление последнего элемента
            myList.remove(myList.size() - 1);
        
            // Создание стека
            Stack<Integer> stack = new Stack<>();
        
            // Добавление элементов в стек (push)
            stack.push(10);
            stack.push(20);
            stack.push(30);
        
            // Удаление и получение верхнего элемента из стека (pop)
            int popped = stack.pop();
        }
    }
Особенности:

Массивы фиксированы при создании.

ArrayList — динамический аналог, требует импорта java.util.ArrayList.

Типизированность: нельзя смешивать типы данных.

Примитивные типы (например, int) требуют использования классов-оберток (например, Integer) в ArrayList.Java: java.util.Deque (Интерфейс)

В Java Deque — это интерфейс, который реализуют два основных класса: ArrayDeque и LinkedList.

· `ArrayDeque`: Реализация на основе кольцевого буфера (массива). Это предпочтительный выбор для большинства случаев.
· `LinkedList`: Реализация на основе двусвязного списка. Также реализует интерфейсы List и Queue.

Особенности `ArrayDeque`:

· Более эффективная по памяти, чем LinkedList (не нужно хранить ссылки на узлы).
· Производительность: Операции с концами — амортизированное O(1). Операции по индексу в середине — O(n).
· Не потокобезопасен.

# C++
    #include <vector>
    #include <stack>
    using namespace std;

    int main() {
        // Создание вектора (динамического массива)
        vector<int> my_vector = {1, 2, 3, 4, 5};
    
        // Добавление элемента в конец вектора
        my_vector.push_back(6);
    
        // Удаление последнего элемента
        my_vector.pop_back();
    
        // Создание стека
        stack<int> my_stack;
    
        // Добавление элементов в стек (push)
        my_stack.push(10);
        my_stack.push(20);
        my_stack.push(30);
    
        // Удаление верхнего элемента из стека (pop)
        my_stack.pop();
    
    }
Особенности:

Массивы фиксированного размера (синтаксис в стиле C).

vector из STL — динамический аналог, требует подключения <vector>.

Типизированность, как в Java.

Прямой доступ к памяти, что может дать преимущество в производительности.
В C++ дек является частью Standard Template Library (STL). Его реализация — это чаще всего набор фрагментов (чанков) динамического массива, что обеспечивает эффективный произвольный доступ по индексу.

Особенности:

· Контроль памяти: Памятью управляет сам контейнер, но разработчик может влиять на её выделение (например, с помощью reserve).
· Произвольный доступ: Операция доступа по индексу (operator[]) выполняется за O(1).
· Сложность операций: Вставка и удаление в начало/конец — амортизированное O(1). Вставка/удаление в середину — O(n).
· Итераторы: Поддерживаются прямые и обратные итераторы, но итераторы могут стать недействительными после операций модификации.
Сравнение языков

Java и C++ требуют явного объявления типов, но это повышает надежность кода.

C++ дает больше контроля над памятью, но сложнее в изучении.

Java балансирует между простотой и производительностью, но требует больше кода, чем Python.

Вывод:

Для быстрого прототипирования и простых задач — Python.

Для кроссплатформенных приложений и большых проектов — Java.

Для задач, где критична производительность и низкоуровневый контроль — C++.
Для алгоритмов и общего использования:
  · C++ `std::deque` — самый мощный и универсальный. Идеален, когда нужен не только дек, но и быстрый произвольный доступ по индексу.
  · Java `ArrayDeque` — отличный баланс производительности и простоты использования. Лучший выбор для реализации очередей и стеков в Java.
· Для многопоточности:
  · Python `deque` имеет встроенную потокобезопасность для определенных операций, что удобно без дополнительных ухищрений. В C++ и Java для потокобезопасности нужны внешние механизмы (например, synchronized в Java или мьютексы в C++).
· Для простоты и читаемости кода:
  · Python `deque` предлагает самый лаконичный и понятный синтаксис с уникальными методами вроде rotate().
